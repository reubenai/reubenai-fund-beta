// Enhanced Strategy Service for comprehensive strategy processing

import { supabase } from '@/integrations/supabase/client';
import { EnhancedWizardData, CategoryCustomization, EnhancedCategoryConfig } from '@/types/enhanced-strategy';
import { intelligentCriteriaService } from './IntelligentCriteriaService';

interface DealDefinitionTemplate {
  id?: string;
  fund_id: string;
  sector?: string;
  stage?: string;
  geography?: string;
  criteria: any;
  scoring_weights: any;
  created_at?: string;
  updated_at?: string;
}

class EnhancedStrategyService {
  // Generate comprehensive criteria from wizard data
  async generateEnhancedCriteria(wizardData: EnhancedWizardData): Promise<EnhancedCategoryConfig[]> {
    const categories = [
      { name: 'Team & Leadership', config: wizardData.teamLeadershipConfig },
      { name: 'Market Opportunity', config: wizardData.marketOpportunityConfig },
      { name: 'Product & Technology', config: wizardData.productTechnologyConfig },
      { name: 'Business Traction', config: wizardData.businessTractionConfig },
      { name: 'Financial Health', config: wizardData.financialHealthConfig },
      { name: 'Strategic Fit', config: wizardData.strategicFitConfig }
    ];

    const enhancedCriteria: EnhancedCategoryConfig[] = [];

    for (const category of categories) {
      // Generate intelligent signals based on sectors
      const sectorSpecificCriteria = intelligentCriteriaService.generateSectorSpecificCriteria(wizardData.sectors);
      
      // Merge with user-defined criteria
      const enhancedCategory: EnhancedCategoryConfig = {
        name: category.name,
        weight: category.config.weight,
        subcategories: Object.entries(category.config.subcategories).map(([name, config]) => ({
          name,
          weight: config.weight,
          requirements: config.requirements || intelligentCriteriaService.generateSubcategoryRequirements(
            category.name,
            name,
            wizardData.sectors,
            wizardData.stages
          ),
          enabled: config.enabled
        })),
        positiveSignals: [
          ...category.config.positiveSignals,
          ...(sectorSpecificCriteria.positiveSignals || [])
        ].filter((signal, index, array) => array.indexOf(signal) === index), // Remove duplicates
        negativeSignals: [
          ...category.config.negativeSignals,
          ...(sectorSpecificCriteria.negativeSignals || [])
        ].filter((signal, index, array) => array.indexOf(signal) === index),
        description: this.generateCategoryDescription(category.name, wizardData.sectors)
      };

      enhancedCriteria.push(enhancedCategory);
    }

    return enhancedCriteria;
  }

  // Save enhanced strategy with comprehensive data
  async saveEnhancedStrategy(fundId: string, wizardData: EnhancedWizardData): Promise<boolean> {
    try {
      // Generate enhanced criteria
      const enhancedCriteria = await this.generateEnhancedCriteria(wizardData);

      // Create or update investment strategy
      const strategyData = {
        fund_id: fundId,
        industries: wizardData.sectors,
        geography: wizardData.geographies,
        min_investment_amount: wizardData.checkSizeMin * 1000000, // Convert to actual amount
        max_investment_amount: wizardData.checkSizeMax * 1000000,
        key_signals: this.extractKeySignals(enhancedCriteria),
        exciting_threshold: wizardData.dealThresholds.exciting,
        promising_threshold: wizardData.dealThresholds.promising,
        needs_development_threshold: wizardData.dealThresholds.needs_development,
        strategy_notes: wizardData.strategyDescription,
        enhanced_criteria: {
          categories: enhancedCriteria,
          fundType: wizardData.fundType,
          generatedAt: new Date().toISOString(),
          stages: wizardData.stages
        }
      };

      // Check if strategy exists
      const { data: existingStrategy } = await supabase
        .from('investment_strategies')
        .select('id')
        .eq('fund_id', fundId)
        .maybeSingle();

      if (existingStrategy) {
        // Update existing strategy
        const { error } = await supabase
          .from('investment_strategies')
          .update(strategyData)
          .eq('id', existingStrategy.id);

        if (error) throw error;
      } else {
        // Create new strategy
        const { error } = await supabase
          .from('investment_strategies')
          .insert(strategyData);

        if (error) throw error;
      }

      // Generate and save deal definition templates
      await this.autoGenerateDealDefinitions(fundId, wizardData, enhancedCriteria);

      return true;
    } catch (error) {
      console.error('Error saving enhanced strategy:', error);
      return false;
    }
  }

  // Auto-generate deal definition templates for different contexts
  async autoGenerateDealDefinitions(
    fundId: string, 
    wizardData: EnhancedWizardData,
    enhancedCriteria: EnhancedCategoryConfig[]
  ): Promise<void> {
    // For now, we'll store deal definitions in the investment_strategies table
    // as part of the enhanced_criteria JSON field
    // This can be moved to a separate table later when the schema is updated
    
    const dealDefinitions = {
      sectorStageTemplates: {} as Record<string, any>,
      geographyTemplates: {} as Record<string, any>
    };

    // Generate templates for each sector-stage combination
    for (const sector of wizardData.sectors) {
      for (const stage of wizardData.stages) {
        const key = `${sector}-${stage}`;
        dealDefinitions.sectorStageTemplates[key] = {
          sector,
          stage,
          criteria: this.generateDealCriteria(sector, stage, enhancedCriteria),
          scoring_weights: this.generateScoringWeights(enhancedCriteria)
        };
      }
    }

    // Also create general templates for each geography
    for (const geography of wizardData.geographies) {
      dealDefinitions.geographyTemplates[geography] = {
        geography,
        criteria: this.generateGeographicCriteria(geography, enhancedCriteria),
        scoring_weights: this.generateScoringWeights(enhancedCriteria)
      };
    }

    // Store deal definitions as part of the strategy for now
    console.log('Generated deal definitions:', dealDefinitions);
  }

  // Generate deal-specific criteria
  private generateDealCriteria(
    sector: string, 
    stage: string, 
    enhancedCriteria: EnhancedCategoryConfig[]
  ): any {
    const criteria: any = {};

    enhancedCriteria.forEach(category => {
      criteria[category.name] = {
        weight: category.weight,
        subcategories: category.subcategories.filter(sub => sub.enabled),
        positiveSignals: category.positiveSignals,
        negativeSignals: category.negativeSignals,
        sectorFocus: sector,
        stageFocus: stage
      };
    });

    return criteria;
  }

  // Generate geographic-specific criteria
  private generateGeographicCriteria(
    geography: string,
    enhancedCriteria: EnhancedCategoryConfig[]
  ): any {
    const criteria: any = {};

    enhancedCriteria.forEach(category => {
      criteria[category.name] = {
        weight: category.weight,
        subcategories: category.subcategories.filter(sub => sub.enabled),
        positiveSignals: category.positiveSignals,
        negativeSignals: category.negativeSignals,
        geographicFocus: geography
      };
    });

    return criteria;
  }

  // Generate scoring weights for AI system
  private generateScoringWeights(enhancedCriteria: EnhancedCategoryConfig[]): any {
    const weights: any = {};

    enhancedCriteria.forEach(category => {
      weights[category.name] = {
        categoryWeight: category.weight / 100, // Convert to decimal
        subcategoryWeights: {}
      };

      category.subcategories.forEach(subcategory => {
        if (subcategory.enabled) {
          weights[category.name].subcategoryWeights[subcategory.name] = subcategory.weight / 100;
        }
      });
    });

    return weights;
  }

  // Extract key signals across all categories
  private extractKeySignals(enhancedCriteria: EnhancedCategoryConfig[]): string[] {
    const allSignals: string[] = [];

    enhancedCriteria.forEach(category => {
      allSignals.push(...category.positiveSignals);
    });

    // Return top signals (remove duplicates and limit)
    return [...new Set(allSignals)].slice(0, 20);
  }

  // Generate category description based on sector focus
  private generateCategoryDescription(categoryName: string, sectors: string[]): string {
    const descriptions: Record<string, string> = {
      'Team & Leadership': `Evaluate founding team strength, leadership experience, and execution capability${sectors.length ? ` with focus on ${sectors.join(', ')} sectors` : ''}.`,
      'Market Opportunity': `Assess market size, timing, and competitive dynamics${sectors.length ? ` within ${sectors.join(', ')} markets` : ''}.`,
      'Product & Technology': `Analyze product innovation, technology advantages, and differentiation${sectors.length ? ` in ${sectors.join(', ')} space` : ''}.`,
      'Business Traction': `Review revenue growth, customer metrics, and market validation${sectors.length ? ` for ${sectors.join(', ')} businesses` : ''}.`,
      'Financial Health': `Examine financial performance, capital efficiency, and unit economics${sectors.length ? ` typical of ${sectors.join(', ')} companies` : ''}.`,
      'Strategic Fit': `Determine portfolio synergies, thesis alignment, and value creation potential${sectors.length ? ` within ${sectors.join(', ')} portfolio` : ''}.`
    };

    return descriptions[categoryName] || 'Evaluate this investment criteria category.';
  }

  // Validate enhanced strategy completeness
  validateEnhancedStrategy(wizardData: EnhancedWizardData): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];

    // Basic validation
    if (!wizardData.fundName?.trim()) errors.push('Fund name is required');
    if (!wizardData.strategyDescription?.trim()) errors.push('Strategy description is required');
    if (!wizardData.sectors?.length) errors.push('At least one sector must be selected');
    if (!wizardData.stages?.length) errors.push('At least one stage must be selected');
    if (!wizardData.geographies?.length) errors.push('At least one geography must be selected');

    // Check size validation
    if (wizardData.checkSizeMax <= wizardData.checkSizeMin) {
      errors.push('Maximum check size must be greater than minimum');
    }

    // Category weight validation
    const categories = [
      wizardData.teamLeadershipConfig,
      wizardData.marketOpportunityConfig,
      wizardData.productTechnologyConfig,
      wizardData.businessTractionConfig,
      wizardData.financialHealthConfig,
      wizardData.strategicFitConfig
    ];

    const totalWeight = categories.reduce((sum, cat) => sum + (cat?.weight || 0), 0);
    if (Math.abs(totalWeight - 100) > 0.1) {
      errors.push(`Category weights must sum to 100% (currently ${totalWeight.toFixed(1)}%)`);
    }

    // Subcategory validation
    categories.forEach((category, index) => {
      if (category?.subcategories) {
        const enabledSubcategories = Object.values(category.subcategories).filter(sub => sub.enabled);
        if (enabledSubcategories.length === 0) {
          const categoryNames = ['Team & Leadership', 'Market Opportunity', 'Product & Technology', 'Business Traction', 'Financial Health', 'Strategic Fit'];
          errors.push(`${categoryNames[index]} must have at least one enabled subcategory`);
        }

        const subcategoryWeights = enabledSubcategories.reduce((sum, sub) => sum + (sub.weight || 0), 0);
        if (Math.abs(subcategoryWeights - 100) > 0.1) {
          const categoryNames = ['Team & Leadership', 'Market Opportunity', 'Product & Technology', 'Business Traction', 'Financial Health', 'Strategic Fit'];
          errors.push(`${categoryNames[index]} subcategory weights must sum to 100% (currently ${subcategoryWeights.toFixed(1)}%)`);
        }
      }
    });

    // Deal threshold validation
    if (wizardData.dealThresholds.exciting <= wizardData.dealThresholds.promising) {
      errors.push('Exciting threshold must be higher than promising threshold');
    }
    if (wizardData.dealThresholds.promising <= wizardData.dealThresholds.needs_development) {
      errors.push('Promising threshold must be higher than needs development threshold');
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  }
}

export const enhancedStrategyService = new EnhancedStrategyService();