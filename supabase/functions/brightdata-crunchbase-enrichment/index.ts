// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

interface BrightdataRequest {
  dealId: string;
  companyName: string;
  crunchbaseUrl: string;
}

interface BrightdataResponse {
  success: boolean;
  data?: any;
  error?: string;
  data_source: string;
  trust_score: number;
  data_quality: string;
}

Deno.serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    // Create service role client for internal operations
    const authHeader = req.headers.get('Authorization');
    const supabaseClient = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? '',
      authHeader ? {
        global: {
          headers: { Authorization: authHeader },
        },
      } : undefined
    );

    const { dealId, companyName, crunchbaseUrl }: BrightdataRequest = await req.json();

    console.log(`üîç [Brightdata] Enriching company: ${companyName} with Crunchbase: ${crunchbaseUrl}`);

    // Validate input
    if (!crunchbaseUrl) {
      console.log('‚ùå [Brightdata] Missing crunchbaseUrl');
      return new Response(
        JSON.stringify({ 
          success: false, 
          error: 'Crunchbase URL is required',
          data_source: 'brightdata',
          trust_score: 0,
          data_quality: 'invalid'
        }),
        { status: 400, headers: corsHeaders }
      );
    }

    // Get Brightdata API key
    const brightdataApiKey = Deno.env.get('BRIGHTDATA_API_KEY');
    if (!brightdataApiKey) {
      console.log('‚ùå [Brightdata] Missing API key');
      return new Response(
        JSON.stringify({ 
          success: false, 
          error: 'BrightData API key not configured',
          data_source: 'brightdata',
          trust_score: 0,
          data_quality: 'invalid'
        }),
        { status: 500, headers: corsHeaders }
      );
    }

    console.log(`üöÄ [Brightdata] Triggering data collection for: ${crunchbaseUrl}`);

    // Trigger BrightData collection
    const triggerResponse = await fetch(
      'https://api.brightdata.com/datasets/v3/trigger?dataset_id=gd_l1vijqt9jfj7olije&include_errors=true',
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${brightdataApiKey}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify([{ url: crunchbaseUrl }])
      }
    );

    if (!triggerResponse.ok) {
      const errorText = await triggerResponse.text();
      console.log(`‚ùå [Brightdata] Trigger failed: ${errorText}`);
      return new Response(
        JSON.stringify({ 
          success: false, 
          error: `BrightData trigger failed: ${errorText}`,
          data_source: 'brightdata',
          trust_score: 0,
          data_quality: 'failed'
        }),
        { status: 500, headers: corsHeaders }
      );
    }

    const triggerData = await triggerResponse.json();
    const snapshotId = triggerData.snapshot_id;

    console.log(`‚úÖ [Brightdata] Trigger response: ${JSON.stringify(triggerData)}`);

    // Poll for results
    const collectedData = await pollBrightdataSnapshot(snapshotId, brightdataApiKey);
    
    console.log(`‚úÖ [Brightdata] Final data retrieved: ${JSON.stringify(collectedData).substring(0, 500)}...`);

    // Check for existing record
    console.log(`üîç [Brightdata] Checking for existing record with dealId: ${dealId}`);
    const { data: existingRecord } = await supabaseClient
      .from('deal2_enrichment_crunchbase_export')
      .select('id, processing_status')
      .eq('deal_id', dealId)
      .maybeSingle();

    if (existingRecord) {
      console.log(`üìù [Brightdata] Updating existing record (id: ${existingRecord.id}, status: ${existingRecord.processing_status})`);
      // Update existing record
      const { error: updateError } = await supabaseClient
        .from('deal2_enrichment_crunchbase_export')
        .update({
          snapshot_id: snapshotId,
          raw_brightdata_response: collectedData,
          processing_status: 'completed',
          updated_at: new Date().toISOString()
        })
        .eq('id', existingRecord.id);

      if (updateError) {
        console.log(`‚ùå [Brightdata] Update error: ${updateError.message}`);
        return new Response(
          JSON.stringify({ 
            success: false, 
            error: `Database update failed: ${updateError.message}`,
            data_source: 'brightdata',
            trust_score: 0,
            data_quality: 'failed'
          }),
          { status: 500, headers: corsHeaders }
        );
      }
    } else {
      console.log(`üìù [Brightdata] Creating new record for dealId: ${dealId}`);
      // Insert new record
      const { error: insertError } = await supabaseClient
        .from('deal2_enrichment_crunchbase_export')
        .insert({
          deal_id: dealId,
          company_name: companyName,
          crunchbase_url: crunchbaseUrl,
          snapshot_id: snapshotId,
          raw_brightdata_response: collectedData,
          processing_status: 'completed',
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        });

      if (insertError) {
        console.log(`‚ùå [Brightdata] Insert error: ${insertError.message}`);
        return new Response(
          JSON.stringify({ 
            success: false, 
            error: `Database insert failed: ${insertError.message}`,
            data_source: 'brightdata',
            trust_score: 0,
            data_quality: 'failed'
          }),
          { status: 500, headers: corsHeaders }
        );
      }
    }

    console.log('‚úÖ [Brightdata] Raw Crunchbase response stored successfully');

    return new Response(
      JSON.stringify({ 
        success: true, 
        data: collectedData,
        data_source: 'brightdata',
        trust_score: 95,
        data_quality: 'high'
      }),
      { 
        status: 200, 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
      }
    );

  } catch (error) {
    console.log(`‚ùå [Brightdata] Error: ${error.message}`);
    return new Response(
      JSON.stringify({ 
        success: false, 
        error: error.message,
        data_source: 'brightdata',
        trust_score: 0,
        data_quality: 'failed'
      }),
      { 
        status: 500, 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
      }
    );
  }
});

async function pollBrightdataSnapshot(snapshotId: string, apiKey: string, maxAttempts = 10): Promise<any> {
  console.log(`üîÑ [Brightdata] Polling snapshot ${snapshotId}...`);
  
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    console.log(`üìä [Brightdata] Poll attempt ${attempt}/${maxAttempts}`);
    
    try {
      const response = await fetch(
        `https://api.brightdata.com/datasets/v3/snapshot/${snapshotId}?format=json`,
        {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${apiKey}`,
          }
        }
      );

      if (response.ok) {
        const data = await response.json();
        if (data && data.length > 0) {
          console.log(`‚úÖ [Brightdata] Data ready for snapshot ${snapshotId}`);
          return data;
        }
      }

      // Wait before next poll (exponential backoff)
      const waitTime = Math.min(1000 * attempt, 5000);
      console.log(`‚è±Ô∏è [Brightdata] Waiting ${waitTime}ms before next poll...`);
      await new Promise(resolve => setTimeout(resolve, waitTime));
      
    } catch (pollError) {
      console.log(`‚ùå [Brightdata] Poll attempt ${attempt} failed: ${pollError.message}`);
      if (attempt === maxAttempts) {
        throw pollError;
      }
    }
  }
  
  throw new Error(`Data not ready after ${maxAttempts} attempts`);
}